%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% File for initializing simulation parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% initialize velocity first to 0
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
U = gpuArray(zeros(Ny, Nx, Nz));  % x-velocity
V = gpuArray(zeros(Ny, Nx, Nz));  % y-velocity 
W = gpuArray(zeros(Ny, Nx, Nz));  % temperature 
P = gpuArray(zeros(Ny, Nx, Nz));  % pressure
T = gpuArray(zeros(Ny, Nx, Nz));  % transported scalar

FU = gpuArray(zeros(Ny,Nx, Nz));  % tables where Fourier-transforms are stored
FV = gpuArray(zeros(Ny,Nx, Nz));  % e.g. FU = fft2(U)
FW = gpuArray(zeros(Ny,Nx, Nz));  % e.g. FU = fft2(U)
FT = gpuArray(zeros(Ny,Nx, Nz)); 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% wave vectors: see HowToUseFFT2.pdf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
kx1 = mod(1/2 + (0:(Nx-1))/Nx, 1 ) - 1/2;
ky1 = mod(1/2 + (0:(Ny-1))/Ny, 1 ) - 1/2;
kz1 = mod(1/2 + (0:(Nz-1))/Nz, 1 ) - 1/2;
kx  = kx1*(2*pi/dx); % wavenumbers
ky  = ky1*(2*pi/dy); % wavenumbers
kz  = kz1*(2*pi/dy); % wavenumbers

% these are the wave vector modes one gets from fft2
[KX,KY,KZ] = meshgrid(kx,ky,kz); 
KX = gpuArray(KX); KY=gpuArray(KY); KZ=gpuArray(KZ); 

% Anti-aliasing filter based on the 2/3*kNyq rule
AA = gpuArray(double(abs(KZ) < (2/3)*max(kz)).*double(abs(KX) < (2/3)*max(kx)).*double(abs(KY) < (2/3)*max(ky))); 

LP = (1-0.4*(KX/(pi/dx)).^6).*(1-0.4*(KY/(pi/dy)).^6).*(1-0.4*(KZ/(pi/dz)).^6);

% whenever fft2 is called we program AA.*fft2(field) in order to remove the 
% aliasing error

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Runge-Kutta 4 coefficients
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

a1= 1/6; a2 = 1/3; a3 = 1/3; a4 = 1/6;
b1=0.5; b2=0.5; b3=1; b4=1;
a=[a1 a2 a3 a4]; b=[b1 b2 b3 b4];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
DiffIF = gpuArray( (-KX.*KX -KY.*KY - KZ.*KZ)); 

iKX=gpuArray(j*KX);
iKY=gpuArray(j*KY);
iKZ=gpuArray(j*KZ);
KXXP = gpuArray(KX.*KX./max(1e-10,(KX.^2 + KY.^2 + KZ.^2)));
KYYP = gpuArray(KY.*KY./max(1e-10,(KX.^2 + KY.^2  + KZ.^2)));
KZZP = gpuArray(KZ.*KZ./max(1e-10,(KX.^2 + KY.^2  + KZ.^2)));
KXYP = gpuArray(KX.*KY./max(1e-10,(KX.^2 + KY.^2 + KZ.^2)));
KXZP = gpuArray(KX.*KZ./max(1e-10,(KX.^2 + KY.^2 + KZ.^2)));
KYZP = gpuArray(KZ.*KY./max(1e-10,(KX.^2 + KY.^2 + KZ.^2)));


OnePerK = gpuArray(1.0./max(1e-10,(KX.^2 + KY.^2 + KZ.^2)));


xc = Lx/10; yc = Ly/2; zc = Lz/2; 
Lxc = Lx/6; Lyc = Lx/6; Lzc = Ly/6;  

%dnoz = 0.2237; ax = Lx/8; ay = Ly/6; az = Lz/4;
% Initialize with shear layers to drive the flow turbulent
% This part is overrun by initial data later on. 
% In our publication the Ustart data is chosen as initial condition. 
% Such data can be regenerated by running this initial conditions for some
% thousands of timesteps 
dnoz = 0.2237; ax = Lx/8; ay = Ly/6; az = Lz/4; % droplet initial position related 

Uprime = 0.05;
U = Uprime*(round((sin(3*2*pi*Y/Ly) + 1)*0.5) - 0.5)*2  + 0.0*(rand(Ny,Nx,Nz)-0.5);
V = 0.0*(round((sin(3*2*pi*Y/Ly) + 1)*0.5))   + 0.01*(rand(Ny,Nx,Nz)-0.5); 
W = 0.00*(round((sin(3*2*pi*Z/Lz) + 1)*0.5))   + 0.01*(rand(Ny,Nx,Nz)-0.5);



[U,V,W] = project(U,V,W,KX,KY,KZ,AA,OnePerK,KXXP,KYYP,KZZP,KXYP,KXZP,KYZP);

Uold=gpuArray(U); Vold=gpuArray(V); Wold=gpuArray(W); 
Uc=gpuArray(U); Vc=gpuArray(V); Wc=gpuArray(W); 
dU=gpuArray(0*U); dV=gpuArray(0*V); dW=gpuArray(0*W); 